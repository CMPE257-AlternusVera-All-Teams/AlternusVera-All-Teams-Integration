# -*- coding: utf-8 -*-
"""BERT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XINH0UOkFtM8jEBJzCCmTaRtDSVZH7Nt
"""

import transformers
from transformers import BertModel, BertTokenizer
import torch
import torch.nn as nn

class CerealKillers_SentimentClassifier(nn.Module):
  def __init__(self, pathBert):
    super(CerealKillers_SentimentClassifier, self).__init__()
    self.tokenizer = BertTokenizer.from_pretrained(pathBert)
    self.bert = BertModel.from_pretrained(pathBert)
    # self.tokenizer = BertTokenizer.from_pretrained('/content/CerealKillers_AlternusVera/BERT/saved_model/')
    # self.bert = BertModel.from_pretrained('/content/CerealKillers_AlternusVera/BERT/saved_model/')
    self.class_names = ['true','pants-fire']
    self.n_classes = len(self.class_names)
    self.drop = nn.Dropout(p=0.3)
    self.out = nn.Linear(self.bert.config.hidden_size, self.n_classes)

  def forward(self, input_ids, attention_mask):
    _, pooled_output = self.bert(
      input_ids=input_ids,
      attention_mask=attention_mask
    )
    output = self.drop(pooled_output)
    return self.out(output)

  def predict(self, review_text):
    encoded_review = self.tokenizer.encode_plus(
      review_text,
      max_length=512,
      add_special_tokens=True,
      return_token_type_ids=False,
      pad_to_max_length=True,
      return_attention_mask=True,
      return_tensors='pt',
    )
    input_ids = encoded_review['input_ids']
    attention_mask = encoded_review['attention_mask']
    output = self.forward(input_ids, attention_mask)
    _, prediction = torch.max(output,1)
    bert_score = 0
    if prediction.item() == 0:
      bert_score = 1
    elif prediction.item() == 1:
      bert_score = 2
    elif prediction.item() == 2:
      bert_score = 3
    elif prediction.item() == 3:
      bert_score = 4
    elif prediction.item() == 4:
      bert_score = 5
    else:
      bert_score = 6
    return bert_score



"""SocialCredibility.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/155pg_WkViHJmDVHIBbedV-a-UCVh_CDc
"""

from sklearn.ensemble import RandomForestClassifier
import pandas as pd
import tweepy
import configparser
import json
import pickle

class CerealKillers_SocialCredibility:
  def __init__(self, filenameModel, fileApi):
    config = configparser.ConfigParser()
    # config.read('/content/CerealKillers_AlternusVera/SC/twitter_api.ini')
    config.read(fileApi)
    self.user_info = {}
    self.user_data = []
    self.consumer_key        = config.get('default','apikey')
    self.consumer_secret     = config.get('default','apisecretkey')
    self.access_token        = config.get('default','accesstoken')
    self.access_token_secret = config.get('default','accesstokensecret')
    auth = tweepy.OAuthHandler(self.consumer_key, self.consumer_secret)
    auth.set_access_token(self.access_token, self.access_token_secret)
    self.api = tweepy.API(auth, parser=tweepy.parsers.JSONParser())
    self.model = self.__load(filenameModel)
    

  def __load(self, path):
    with open(path, 'rb') as file:
      return pickle.load(file)


  ## Call this first when "name" is present
  def search_user_by_name(self, name):
    search = self.api.search_users(name)
    if search:
      self.user_info = search[0]
      self.set_user_data()
    else:
      self.user_data = [0,0,0,0,0,0,0]

  # Call this second to get data for get_prediction()
  # or just call get_prediction(get_user_data())
  def get_user_data(self):
    return self.user_data

  def predict(self, data):
    X = pd.DataFrame([data], columns=['followers','favorites','friends','listed_count','statuses_count','status_retweeted','status_favorited'])
    
    # RFC = pickle.load( open("/content/CerealKillers_AlternusVera/SC/SocialCredibilityV2.pkl", "rb") )
    # y = RFC.predict(X)
    y = self.model.predict(X)
    return y[0]

  def get_twitter_user_info(self, userid):
    info = {}
    try:
      info = self.api.get_user(int(userid))
    except:
      pass
    finally:
      self.user_info = info
      self.set_user_data()

  def get_user_id(self, info):
    return self.user_info['id']

  def set_user_data(self):
    info = self.user_info
    fol = self.get_followers(info)
    fri = self.get_friends(info)
    fav = self.get_favorites(info)
    lc = self.get_lc(info)
    sc = self.get_sc(info)
    sr = self.get_sr(info)
    sf = self.get_sf(info)
    self.user_data = [fol,fri,fav,lc,sc,sr,sf]

  def get_followers(self,info):
    if bool(info):
      if 'followers_count' in info:
        return info['followers_count']
      else:
        return 0
    else:
      return 0

  def get_friends(self,info):
    if bool(info):
      if 'friends_count' in info:
        return info['friends_count']
      else:
        return 0
    else:
      return 0

  def get_favorites(self,info):
    if bool(info):
      if 'favourites_count' in info:
        return info['favourites_count']
      else:
        return 0
    else:
      return 0

  def get_lc(self,info):
    if bool(info):
      if 'listed_count' in info:
        return info['listed_count']
      else:
        return 0
    else:
      return 0

  def get_sc(self,info):
    if bool(info):
      if 'statuses_count' in info:
        return info['statuses_count']
      else:
        return 0
    else:
      return 0

  def get_sr(self,info):
    if bool(info):
      if 'status' in info:
        if 'retweet_count' in info['status']:
            return info['status']['retweet_count']
        else: return 0
      else:
        return 0
    else:
      return 0

  def get_sf(self,info):
    if bool(info):
      if 'status' in info:
        if 'favorite_count' in info['status']:
          return info['status']['favorite_count'] 
        else: return 0
      else:
        return 0
    else:
      return 0
